# HashMap详解

## 重写equals方法为什么要重写hashcode方法

HashMap 的性能表现非常依赖于哈希码的有效性，请务必掌握 hashCode 和 equals 的一些基本约定，比如：

equals 相等，hashCode 一定要相等。

重写了 hashCode 也要重写 equals。

hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。

equals 的对称、反射、传递等特性。

原则上：equals相等时，hashcode一定相等；hashcode相等时，equals不一定相等

如果单纯重写equals方法不重写hashcode方法，会造成contains失效等问题。

## hashmap的扩容机制是，以及扩容1.5倍或者2倍对扩容速度的影响

[参考链接](https://zhuanlan.zhihu.com/p/114363420)

当map的存储数据的个数大于阈值（容量*负载因子）时，map会开始resize，因此负载因子的选择过大会导致阈值过大，就会引起在map存储了大量的数据仍然没有resize，此时hash冲突严重，map性能下降。如果负载因子选择过小，阈值变小，会导致map频繁扩容，导致性能下降。

扩容选择2倍，是因为不需要重新计算哈希，只需要判断高位是否是0，最高位是0则坐标不变，最高位是1则坐标变为“10000+原坐标”。

## 什么是树化改造，为什么要进行树化改造

在JDK1.8中，HashMap做了一些改变：

JDK1.7中，发生哈希碰撞时，将键值对添加到链表头部，JDK1.8是将键值对添加到链表尾部。
JDK1.8中，如果链表的长度超过8，将会将链表转化为红黑树。
容量的初始化：JDK1.7的HashMap在构造时会对容量进行初始化，而JDK1.8是在首次向HashMap总中执行put操作时，对容量进行初始化，也就是说，JDK1.8的HashMap使用了懒汉模式（在使用时才初始化），避免了初始化后却不用的资源浪费。
那为什么要进行树化的改造呢?

主要是为了避免哈希碰撞拒绝服务攻击。

从性能角度来看：解决哈希冲突时使用链表，插入和删除的效率很高，只需O(1)的时间复杂度，但对于查询而言，则需要O(n)的时间负责度。但红黑树的插入，删除，查询的最差时间复杂度为O(logn)。恶意代码可以利用大量数据与服务器交互，比如String的hashcode函数的强度很弱，有人可以很容易的构造出大量hashcode相同的String对象。如果向服务器一次提交数万个hashcode相同的字符串，服务器的查询时间过长，让服务器的CPU被大量占用，当有其他更多的请求时服务器会拒绝服务。而使用红黑树可以将查询时间降低到一定的数量级，可以有效避免哈希碰撞拒绝服务攻击。
